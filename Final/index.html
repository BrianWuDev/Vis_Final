<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integration Analysis: scRNA vs snRNA</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base Layout - Dark Mode */
        body { margin: 0; overflow: hidden; font-family: "Inter", "Microsoft JhengHei", sans-serif; background-color: #000000; color: #e0e0e0; }
        #chart { width: 100vw; height: 100vh; }
        
        /* Tooltip */
        .tooltip {
            position: absolute; background: #222; color: #fff; padding: 10px;
            border-radius: 4px; pointer-events: none; font-size: 12px;
            box-shadow: 0 2px 5px rgba(255,255,255,0.1); display: none; z-index: 999; line-height: 1.4;
            min-width: 150px; border: 1px solid #444;
        }

        /* Controls (Top Left) */
        .controls {
            position: absolute; top: 15px; left: 15px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px; border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            width: 280px; z-index: 100;
            border: 1px solid #333;
        }
        .controls h2 { margin: 0 0 10px 0; font-size: 18px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; font-weight: 700; }
        .control-group { margin-bottom: 15px; }
        .control-label { display: block; font-size: 12px; font-weight: bold; color: #bbb; margin-bottom: 5px; }
        
        /* Info Panel (Bottom Left) */
        .info-panel {
            position: absolute; bottom: 15px; left: 15px;
            width: 400px; 
            max-height: 300px;
            overflow-y: auto;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px; border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            z-index: 100; 
            font-size: 12px; 
            line-height: 1.5;
            color: #ccc;
            border: 1px solid #333;
        }
        .info-panel h4 { margin: 0 0 5px 0; font-size: 14px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 3px; }
        .info-panel p { margin-bottom: 10px; }
        
        /* Details Panel (Right) */
        .details-panel {
            position: absolute; top: 15px; right: 15px; bottom: 170px; /* Leave space for minimap */
            width: 280px; background: rgba(30, 30, 30, 0.9);
            padding: 20px; border-radius: 4px;
            box-shadow: -2px 0 5px rgba(0,0,0,0.5);
            transform: translateX(120%); transition: transform 0.3s ease-out; 
            z-index: 100; overflow-y: auto; display: flex; flex-direction: column;
            border: 1px solid #333; color: #ccc;
        }
        .details-panel.active { transform: translateX(0); }
        
        .panel-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding-bottom: 8px; margin-bottom: 10px; }
        .panel-title { margin: 0; font-size: 16px; color: #fff; word-break: break-all; }
        .close-btn { background: none; border: none; font-size: 20px; cursor: pointer; color: #999; }
        .close-btn:hover { color: #e15759; }

        .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .stat-box { background: #2a2a2a; padding: 8px; border-radius: 4px; text-align: center; border: 1px solid #444; }
        .stat-val { display: block; font-size: 16px; font-weight: bold; color: #fff; }
        .stat-label { font-size: 10px; color: #888; }

        /* UI Components */
        .mode-btn-group { display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap; }
        .mode-btn { 
            flex: 1; padding: 6px; font-size: 11px; cursor: pointer; border: 1px solid #444; background: #2a2a2a; border-radius: 3px; 
            transition: all 0.1s; font-weight: bold; color: #ccc; white-space: nowrap;
        }
        .mode-btn:hover { background: #3a3a3a; }
        .mode-btn.active { background: #e0e0e0; color: #000; border-color: #fff; }
        .mode-btn.highlight { background: #d62728; color: #fff; border-color: #d62728; }
        
        input[type=range] { width: 100%; margin: 3px 0; accent-color: #4e79a7; cursor: pointer; }
        .search-box { width: 100%; padding: 8px; border: 1px solid #444; border-radius: 3px; box-sizing: border-box; font-size: 12px; background: #2a2a2a; color: #fff; }
        .range-value { float: right; color: #e15759; font-weight: bold; }

        /* Search Autocomplete */
        .suggestions-list {
            position: absolute; width: 100%; background: #2a2a2a; border: 1px solid #444; border-top: none;
            border-radius: 0 0 3px 3px; max-height: 150px; overflow-y: auto; z-index: 1000;
            list-style: none; padding: 0; margin: 0; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: none;
        }
        .suggestions-list li {
            padding: 8px; cursor: pointer; color: #ccc; font-size: 11px; border-bottom: 1px solid #333;
        }
        .suggestions-list li:last-child { border-bottom: none; }
        .suggestions-list li:hover { background: #3a3a3a; color: #fff; }
        .suggestions-list li strong { color: #e15759; }

        /* Legend */
        .legend-area { font-size: 11px; color: #aaa; background: #2a2a2a; padding: 8px; border-radius: 4px; margin-bottom: 8px; border: 1px solid #444; }
        .dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; vertical-align: middle; }

        /* Drawing Styles */
        .node circle { stroke: #000; stroke-width: 0.5px; cursor: pointer; transition: all 0.2s; }
        .node text { font-size: 10px; pointer-events: none; opacity: 0; transition: opacity 0.2s; fill: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        .node:hover text, .node.found text, .node.selected text { opacity: 1; }
        .node:hover circle, .node.selected circle { stroke: #fff; stroke-width: 2px; }
        
        .faded { opacity: 0.1 !important; }
        .active-node { opacity: 1 !important; }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 200px;
            height: 140px;
            border: 1px solid #444;
            background-color: #1e1e1e;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
            z-index: 90;
        }
        .minimap-node { fill: #666; }
        .viewport-rect {
            fill: rgba(78, 121, 167, 0.3);
            stroke: #4e79a7;
            stroke-width: 1px;
        }

        /* Loading */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30,30,30,0.95); padding: 20px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 1000; text-align: center;
            border: 1px solid #444; color: #fff;
        }
        
        /* Literature Panel (Bottom) */
        .literature-panel {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 160px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px; border-radius: 4px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
            z-index: 95; /* Below controls/details but above map */
            border: 1px solid #444; color: #ccc;
            display: none; flex-direction: column;
            overflow: hidden;
        }
        .literature-panel.active { display: flex; }
        .lit-header { 
            display: flex; justify-content: space-between; align-items: center; 
            border-bottom: 1px solid #444; padding-bottom: 8px; margin-bottom: 8px; 
        }
        .lit-title { font-size: 14px; font-weight: bold; color: #fff; }
        .lit-content { overflow-y: auto; flex: 1; font-size: 12px; }
        .paper-item { margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .paper-item:last-child { border-bottom: none; }
        .paper-link { color: #4e79a7; text-decoration: none; font-weight: 500; }
        .paper-link:hover { text-decoration: underline; color: #6baed6; }
        .paper-authors { color: #888; font-size: 11px; margin-top: 2px; }

        /* Loading Spinner for Panel */
        .panel-loader { text-align: center; color: #888; margin-top: 20px; }

        /* Select Dropdown */
        select { background-color: #2a2a2a; color: #fff; border: 1px solid #444; }
    </style>
</head>
<body>

    <div id="loading">
        <h3>Loading Data...</h3>
        <p>Please wait while we load 4000+ cells</p>
    </div>

    <div class="controls">
        <h2>Integration Analysis</h2>
        
        <div class="control-group">
            <label class="control-label">Embedding Method:</label>
            <div class="mode-btn-group" id="projection-selector">
                <button class="mode-btn active" onclick="setProjection('supcpm')">SupCPM</button>
                <button class="mode-btn" onclick="setProjection('umap')">UMAP</button>
                <button class="mode-btn" onclick="setProjection('tsne')">t-SNE</button>
                <button class="mode-btn" onclick="setProjection('pca')">PCA</button>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">View Mode (Color By):</label>
            <div class="mode-btn-group" id="mode-selector">
                <button class="mode-btn active" onclick="setMode('type')">Type (sc/sn)</button>
                <button class="mode-btn" onclick="setMode('cluster')">Cluster</button>
            </div>
        </div>

        <div class="control-group" style="border-top: 1px solid #444; padding-top: 15px; margin-top: 15px;">
            <label class="control-label">Gene Expression:</label>
            <select id="gene-selector" style="width:100%; padding:5px; border-radius:3px; border:1px solid #444; background: #2a2a2a; color: white;">
                <option value="">None (Color by Mode)</option>
                <!-- Options populated by JS -->
            </select>
            <div id="gene-legend" style="margin-top:10px; display:none;">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#aaa; margin-bottom:2px;">
                    <span>Low</span>
                    <span>High</span>
                </div>
                <div style="height:10px; background:linear-gradient(to right, #2a2a2a, #4e79a7); border-radius:2px;"></div>
            </div>
        </div>

        <div class="legend-area" id="legend"></div>

        <div class="control-group">
            <label class="control-label">
                Filter Min Genes: <span id="minGeneVal" class="range-value">0</span>
            </label>
            <input type="range" id="minGeneSlider" min="0" max="5000" value="0" step="100">
        </div>
        
        <div class="control-group" style="position: relative;">
            <input type="text" id="search" class="search-box" placeholder="Search Cell ID..." autocomplete="off">
            <ul id="search-suggestions" class="suggestions-list"></ul>
            <div id="search-result" style="font-size:11px; color:#e15759; margin-top:3px; height:15px; font-weight:bold;"></div>
        </div>
    </div>

    <div class="info-panel" style="display:none;">
        <h4>About This Visualization</h4>
        <p>
            <strong>Data:</strong> Mouse Brain Organoid (GSE161340).<br>
            Comparison of Single-Cell (scRNA) and Single-Nucleus (snRNA) sequencing data integration.
        </p>
        <p>
            <strong>SupCPM:</strong> Supervised Capacity Preserving Mapping. A novel visualization method that combines unsupervised geometry preservation (like t-SNE) with supervised cluster separation.
        </p>
        <p>
            <strong>How to use:</strong>
            <ul>
                <li>Switch methods to compare embeddings.</li>
                <li>Hover/Click cells for details.</li>
            </ul>
        </p>
    </div>

    <!-- Gene Expression Panel Removed (Integrated into Controls) -->
    
    <div id="literature-panel" class="literature-panel">
        <div class="lit-header">
            <span class="lit-title">Related Literature (Top Genes)</span>
            <button class="close-btn" onclick="closeLiterature()">×</button>
        </div>
        <div id="lit-content" class="lit-content">
            <div class="panel-loader">Hover over a cell to see related papers...</div>
        </div>
    </div>

    <div id="details-panel" class="details-panel">
        <div class="panel-header">
            <h3 class="panel-title" id="detail-id">Cell ID</h3>
            <button class="close-btn" onclick="clearSelection()">×</button>
        </div>
        
        <div class="stat-grid">
            <div class="stat-box">
                <span class="stat-val" id="detail-genes">0</span>
                <span class="stat-label">Genes</span>
            </div>
            <div class="stat-box">
                <span class="stat-val" id="detail-mito">0%</span>
                <span class="stat-label">Mito %</span>
            </div>
        </div>

        <div style="margin-bottom: 15px; font-size:13px; line-height: 1.6;">
            <div><b style="color:#888;">Type:</b> <span id="detail-type"></span></div>
            <div><b style="color:#888;">Condition:</b> <span id="detail-condition"></span></div>
            <div><b style="color:#888;">Cluster:</b> <span id="detail-cluster"></span></div>
        </div>

        <div id="expression-chart" style="margin-top:auto;">
            <!-- Simple bar chart for markers could go here -->
        </div>
    </div>

    <div id="chart"></div>
    <div id="minimap-container"></div>
    <div class="tooltip" id="tooltip"></div>

<script>
    // Configuration
    const width = window.innerWidth;
    const height = window.innerHeight;
    const COLORS = {
        scRNA: '#4e79a7', // Blue
        snRNA: '#e15759', // Red
        unknown: '#ccc'
    };

    // D3 Setup
    const svg = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height)
        .on("click", (event) => {
            if(event.target.tagName === 'svg') clearSelection();
        });

    const g = svg.append("g");
    const nodeGroup = g.append("g").attr("class", "nodes");

    // Minimap Setup
    const minimapWidth = 200, minimapHeight = 140;
    const minimap = d3.select("#minimap-container").append("svg")
        .attr("width", minimapWidth)
        .attr("height", minimapHeight);
    const viewportRect = minimap.append("rect").attr("class", "viewport-rect");

    // Zoom Behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 8])
        .on("zoom", (event) => {
            if (event.sourceEvent && event.sourceEvent.type === "brush") return; 
            g.attr("transform", event.transform);
            updateViewport(event.transform);
        });
    svg.call(zoom);

    // Minimap Interaction
    const drag = d3.drag()
        .on("start", () => viewportRect.attr("cursor", "grabbing"))
        .on("drag", (event) => {
            const transform = d3.zoomTransform(svg.node());
            const dx = event.dx * (width / minimapWidth) / transform.k;
            const dy = event.dy * (height / minimapHeight) / transform.k;
            zoom.translateBy(svg, -dx, -dy);
        })
        .on("end", () => viewportRect.attr("cursor", "grab"));
    
    viewportRect.call(drag).attr("cursor", "grab");

    minimap.on("click", function(event) {
        const [mx, my] = d3.pointer(event);
        const x = xScaleMini.invert(mx);
        const y = yScaleMini.invert(my);
        
        svg.transition().duration(750)
            .call(zoom.transform, 
                  d3.zoomIdentity.translate(width / 2, height / 2)
                  .scale(d3.zoomTransform(svg.node()).k)
                  .translate(-xScale(x), -yScale(y))
            );
    });

    // State
    let rawData = [];
    let clusters = [];
    let geneExpression = null;
    let xScale, yScale, xScaleMini, yScaleMini;
    let currentMode = 'type'; // type, cluster, or gene
    let currentGene = null;
    let currentProjection = 'supcpm';
    let selectedNodeId = null;
    let hoverTimeout = null; // For debouncing PubMed API calls
    
    // Load Data
    Promise.all([
        d3.json("data/cells.json"),
        d3.json("data/clusters.json"),
        d3.json("data/gene_expression.json")
    ]).then(function([cells, clusterData, geneExpr]) {
        rawData = cells;
        clusters = clusterData;
        geneExpression = geneExpr;
        
        // Hide loading
        d3.select("#loading").style("display", "none");

        // Pre-process random start positions for animation
        rawData.forEach(d => {
            d.random_x = (Math.random() - 0.5) * 20;
            d.random_y = (Math.random() - 0.5) * 20;
        });

        updateLegend();
        
        // Setup slider range based on data
        const maxGenes = d3.max(cells, d => d.n_genes) || 5000;
        d3.select("#minGeneSlider").attr("max", maxGenes);

        // Initialize Visualization
        setProjection('supcpm');
        populateGeneSelector();

        // Event Listeners
        d3.select("#minGeneSlider").on("input", function() {
            d3.select("#minGeneVal").text(this.value);
            updateChart();
        });

        d3.select("#gene-selector").on("change", function() {
            const gene = this.value;
            if (gene) {
                setMode('gene', gene);
            } else {
                setMode('type'); // Default back to type
            }
        });
        
        d3.select("#search").on("input", function() {
            const val = this.value.trim().toLowerCase();
            const nodes = nodeGroup.selectAll(".node");
            const resultDiv = d3.select("#search-result");
            const suggestions = d3.select("#search-suggestions");
            
            if (!selectedNodeId) {
                nodes.classed("found", false).style("opacity", 1);
            }
            
            if(val === "") { 
                resultDiv.text(""); 
                suggestions.style("display", "none");
                return; 
            }

            // Autocomplete logic
            const matches = rawData.filter(d => d.cell_id.toLowerCase().includes(val)).slice(0, 10);
            
            suggestions.html("").style("display", matches.length ? "block" : "none");
            
            matches.forEach(d => {
                const li = suggestions.append("li")
                    .html(d.cell_id.replace(new RegExp(val, "gi"), match => `<strong>${match}</strong>`))
                    .on("click", () => {
                        d3.select("#search").property("value", d.cell_id);
                        suggestions.style("display", "none");
                        // Trigger search/selection
                        selectNode(d);
                        // Center view on node (optional)
                    });
            });

            // Real-time highlighting
            const target = nodes.filter(d => d.cell_id.toLowerCase().includes(val));
            if (!target.empty()) {
                if (!selectedNodeId) nodes.style("opacity", 0.05);
                target.style("opacity", 1).classed("found", true);
                resultDiv.text(`Found ${target.size()} cells`);
            } else {
                resultDiv.text("Not found");
            }
        });
        
        // Hide suggestions on click outside
        d3.select("body").on("click", (event) => {
            if (event.target.id !== "search") {
                d3.select("#search-suggestions").style("display", "none");
            }
        });

    }).catch(err => {
        console.error(err);
        d3.select("#loading").html("<h3>Error Loading Data</h3><p>Please check console.</p>");
    });

    function populateGeneSelector() {
        if (!geneExpression) return;
        const genes = Object.keys(geneExpression);
        const selector = d3.select("#gene-selector");
        
        genes.forEach(gene => {
            selector.append("option").attr("value", gene).text(gene);
        });
    }

    function setProjection(method) {
        currentProjection = method;
        d3.selectAll("#projection-selector .mode-btn").classed("active", false);
        d3.select(`button[onclick="setProjection('${method}')"]`).classed("active", true);
        
        updateScales(method);
        drawMinimapNodes();
        updateChart(true); // true = animate
    }

    function playAnimation() {
        // 1. Switch to "Random" or "PCA" quickly
        // 2. Transition to SupCPM slowly
        
        // Temporarily set scales to supcpm range but draw points at random positions
        const method = 'supcpm';
        updateScales(method);
        
        // Reset view
        nodeGroup.selectAll(".node")
            .transition().duration(500)
            .attr("transform", d => `translate(${xScale(d.random_x)},${yScale(d.random_y)})`)
            .style("opacity", 0.5);

        // Then move to SupCPM
        setTimeout(() => {
            setProjection('supcpm');
        }, 600);
    }

    function updateScales(method) {
        const padding = 50;
        const xKey = method === 'supcpm' ? 'supcpm_x' : `${method}_x`;
        const yKey = method === 'supcpm' ? 'supcpm_y' : `${method}_y`;
        
        const xExtent = d3.extent(rawData, d => d[xKey]);
        const yExtent = d3.extent(rawData, d => d[yKey]);
        
        xScale = d3.scaleLinear().domain(xExtent).range([padding, width - padding]);
        yScale = d3.scaleLinear().domain(yExtent).range([padding, height - padding]);
        
        xScaleMini = d3.scaleLinear().domain(xExtent).range([0, minimapWidth]);
        yScaleMini = d3.scaleLinear().domain(yExtent).range([0, minimapHeight]);

        updateViewport(d3.zoomTransform(svg.node()));
    }

    function updateViewport(transform) {
        if (!xScale || !yScaleMini) return;
        const [topLeft, bottomRight] = [transform.invert([0, 0]), transform.invert([width, height])];
        
        viewportRect
            .attr("x", xScaleMini(topLeft[0]))
            .attr("y", yScaleMini(topLeft[1]))
            .attr("width", Math.max(0, xScaleMini(bottomRight[0]) - xScaleMini(topLeft[0])))
            .attr("height", Math.max(0, yScaleMini(bottomRight[1]) - yScaleMini(topLeft[1])));
    }

    function drawMinimapNodes() {
        minimap.selectAll(".minimap-node").remove();
        
        const xKey = currentProjection === 'supcpm' ? 'supcpm_x' : `${currentProjection}_x`;
        const yKey = currentProjection === 'supcpm' ? 'supcpm_y' : `${currentProjection}_y`;

        // Downsample for minimap if too many points
        const step = Math.ceil(rawData.length / 2000); // Limit to ~2000 points
        const miniData = rawData.filter((d, i) => i % step === 0);

        minimap.append("g")
            .selectAll(".minimap-node")
            .data(miniData)
            .enter().append("circle")
            .attr("class", "minimap-node")
            .attr("cx", d => xScaleMini(d[xKey]))
            .attr("cy", d => yScaleMini(d[yKey]))
            .attr("r", 1.5)
            .attr("fill", d => {
                 const idx = rawData.indexOf(d);
                 return getNodeColor(d, idx);
            });
    }

    function setMode(mode, gene = null) {
        currentMode = mode;
        currentGene = gene;
        
        if (mode !== 'gene') {
            d3.selectAll("#mode-selector .mode-btn").classed("active", false);
            d3.select(`button[onclick="setMode('${mode}')"]`).classed("active", true);
            d3.select("#gene-selector").property("value", ""); // Reset selector
            d3.select("#gene-legend").style("display", "none");
        } else {
            d3.selectAll("#mode-selector .mode-btn").classed("active", false);
             d3.select("#gene-legend").style("display", "block");
        }
        
        updateLegend();
        
        // Update colors only
        nodeGroup.selectAll(".node circle")
            .transition().duration(300)
            .attr("fill", function(d) {
                const idx = rawData.indexOf(d);
                return getNodeColor(d, idx);
            });
            
        drawMinimapNodes();
    }

    function updateLegend() {
        const div = d3.select("#legend");
        let html = "";
        
        if (currentMode === 'type') {
            html += `<div><span class="dot" style="background:${COLORS.scRNA}"></span>scRNA</div>`;
            html += `<div><span class="dot" style="background:${COLORS.snRNA}"></span>snRNA</div>`;
        } else if (currentMode === 'cluster') {
            // Clusters
            clusters.forEach(c => {
                html += `<div><span class="dot" style="background:${c.color}"></span>${c.name}</div>`;
            });
        } else if (currentMode === 'gene') {
             html = "<div>Color intensity represents gene expression level</div>";
        }
        div.html(html);
    }

    function getNodeColor(d, i = -1) {
        if (currentMode === 'type') {
            if (d.type === 'scRNA') return COLORS.scRNA;
            if (d.type === 'snRNA') return COLORS.snRNA;
            return COLORS.unknown;
        } else if (currentMode === 'cluster') {
            // Cluster color
            const c = clusters.find(c => c.id == d.cluster);
            return c ? c.color : '#ccc';
        } else if (currentMode === 'gene' && currentGene && geneExpression) {
             // Find index if not provided (inefficient but safe fallback)
             let idx = i;
             if (idx === -1) idx = rawData.indexOf(d);
             
             if (idx !== -1) {
                 const val = geneExpression[currentGene][idx];
                 // Simple linear scale for now, max ~3.0
                 const maxVal = 3.0; 
                 // Use a blue scale
                 return d3.interpolateBlues(val / maxVal);
             }
             return '#eee';
        }
        return '#ccc';
    }

    function updateChart(animate = false) {
        if (!xScale) return;

        const minGenes = +d3.select("#minGeneSlider").property("value");
        const filteredNodes = rawData.filter(d => d.n_genes >= minGenes);
        
        const xKey = currentProjection === 'supcpm' ? 'supcpm_x' : `${currentProjection}_x`;
        const yKey = currentProjection === 'supcpm' ? 'supcpm_y' : `${currentProjection}_y`;

        const nodes = nodeGroup.selectAll(".node")
            .data(filteredNodes, d => d.cell_id);
            
        nodes.exit().transition().duration(300).style("opacity", 0).remove();
        
        const nodesEnter = nodes.enter().append("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${xScale(d[xKey])},${yScale(d[yKey])})`)
            .style("opacity", 0);
            
        nodesEnter.append("circle")
            .attr("r", 2.5) // scRNA points are small
            .attr("fill", (d, i) => getNodeColor(d, i)); // Warning: index i here is for entered selection, might not align with rawData index if filtered
            
        // No text labels by default for scRNA (too crowded)

        nodesEnter.transition().duration(500).style("opacity", 1);
        
        const allNodes = nodes.merge(nodesEnter);
        
        // Re-apply color to ensure correct mapping (since filteredNodes might change order/indices)
        // We need robust index mapping for gene expression
        allNodes.select("circle")
            .attr("fill", function(d) {
                 const idx = rawData.indexOf(d); // Robust lookup
                 return getNodeColor(d, idx);
            });
        
        if (animate) {
            allNodes.transition().duration(1000)
                .attr("transform", d => `translate(${xScale(d[xKey])},${yScale(d[yKey])})`);
        } else {
            allNodes.attr("transform", d => `translate(${xScale(d[xKey])},${yScale(d[yKey])})`);
        }
        
        // Update appearance
        // allNodes.select("circle")
        //    .attr("fill", d => getNodeColor(d)); // Done above


        // Interactions
        allNodes.on("click", (event, d) => {
            event.stopPropagation();
            selectNode(d);
        });

        allNodes.on("mouseover", function(event, d) {
            if (selectedNodeId && selectedNodeId !== d.cell_id) return;

            const tooltip = d3.select("#tooltip");
            let content = `<div style="font-weight:bold; color:#ffcc00">${d.cell_id}</div>`;
            content += `Type: ${d.type}<br>Cluster: ${d.cluster}`;
            
            tooltip.style("display", "block").html(content);
            
            if (!selectedNodeId) {
                allNodes.style("opacity", 0.1);
                d3.select(this).style("opacity", 1).select("circle").attr("stroke", "#fff").attr("stroke-width", 2);
            }

            // Trigger PubMed Fetch (Debounced)
            clearTimeout(hoverTimeout);
            hoverTimeout = setTimeout(() => {
                fetchLiterature(d);
            }, 800); // 800ms delay to avoid spamming
        })
        .on("mousemove", (event) => d3.select("#tooltip").style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 15) + "px"))
        .on("mouseout", function() {
            d3.select("#tooltip").style("display", "none");
            
            // Cancel pending fetch if mouse leaves quickly
            clearTimeout(hoverTimeout);

            if (!selectedNodeId) {
                allNodes.style("opacity", 1);
                d3.select(this).select("circle").attr("stroke", "#000").attr("stroke-width", 0.5);
            }
        });
    }

    function closeLiterature() {
        d3.select("#literature-panel").classed("active", false);
        clearTimeout(hoverTimeout);
    }

    // --- PubMed Integration ---

    async function fetchLiterature(d) {
        if (!geneExpression) return;
        
        // Show panel and loading state
        const panel = d3.select("#literature-panel");
        const contentDiv = d3.select("#lit-content");
        const titleSpan = d3.select(".lit-title");
        
        panel.classed("active", true);
        contentDiv.html('<div class="panel-loader">Finding top genes and fetching papers...</div>');
        
        // 1. Find Top 5 Expressed Genes for this cell
        const idx = rawData.indexOf(d);
        if (idx === -1) return;

        // Create an array of {gene, value} and sort
        // Note: Iterating 2000 keys is fast enough in modern JS
        const geneList = [];
        for (const [gene, values] of Object.entries(geneExpression)) {
            if (values[idx] > 0) { // Only consider expressed genes
                geneList.push({ gene, val: values[idx] });
            }
        }
        
        // Sort descending
        geneList.sort((a, b) => b.val - a.val);
        const topGenes = geneList.slice(0, 5).map(x => x.gene);
        
        if (topGenes.length === 0) {
            contentDiv.html('<div class="panel-loader">No highly expressed genes found for this cell.</div>');
            return;
        }

        titleSpan.text(`Literature for ${d.cell_id} (Top Genes: ${topGenes.join(', ')})`);

        // 2. Query PubMed
        // Query: (Gene1 OR Gene2 ...) AND (Brain OR Organoid)
        const geneQuery = topGenes.map(g => `${g}[Title/Abstract]`).join(" OR ");
        const term = `(${geneQuery}) AND (brain OR organoid OR neuron)`;
        const encodedTerm = encodeURIComponent(term);
        
        const baseUrl = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils";
        
        try {
            // Step A: ESearch to get IDs
            const searchRes = await fetch(`${baseUrl}/esearch.fcgi?db=pubmed&term=${encodedTerm}&retmode=json&retmax=5&sort=relevance`);
            const searchData = await searchRes.json();
            
            const ids = searchData.esearchresult.idlist;
            
            if (!ids || ids.length === 0) {
                contentDiv.html('<div class="panel-loader">No specific papers found for these genes in this context.</div>');
                return;
            }

            // Step B: ESummary to get titles
            const summaryRes = await fetch(`${baseUrl}/esummary.fcgi?db=pubmed&id=${ids.join(',')}&retmode=json`);
            const summaryData = await summaryRes.json();
            const papers = summaryData.result; // Object keyed by ID
            
            // Render
            let html = "";
            ids.forEach(id => {
                if (papers[id]) { // Check if ID exists in result (sometimes 'uids' list has duplicates or errors)
                    const p = papers[id];
                    // Clean authors list
                    const authors = p.authors ? p.authors.map(a => a.name).slice(0, 3).join(", ") + (p.authors.length > 3 ? " et al." : "") : "Unknown Authors";
                    
                    html += `
                        <div class="paper-item">
                            <a href="https://pubmed.ncbi.nlm.nih.gov/${id}/" target="_blank" class="paper-link">${p.title}</a>
                            <div class="paper-authors">${authors} | ${p.pubdate} | ${p.source}</div>
                        </div>
                    `;
                }
            });
            
            contentDiv.html(html);

        } catch (err) {
            console.error("PubMed API Error:", err);
            contentDiv.html('<div class="panel-loader" style="color:#e15759">Error fetching from PubMed. (Check console or network)</div>');
        }
    }

    function selectNode(d) {
        selectedNodeId = d.cell_id;
        
        // Highlight logic
        const allNodes = nodeGroup.selectAll(".node");
        allNodes.classed("faded", true).classed("active-node", false).style("opacity", 0.1);
        
        // Find the selected node
        const target = allNodes.filter(n => n.cell_id === d.cell_id);
        target.classed("faded", false).classed("active-node", true).style("opacity", 1);
        target.select("circle").attr("stroke", "#fff").attr("stroke-width", 2);

        // Update Details Panel
        const panel = d3.select("#details-panel");
        panel.select("#detail-id").text(d.cell_id);
        panel.select("#detail-genes").text(d.n_genes);
        panel.select("#detail-mito").text(d.pct_mito.toFixed(1) + "%");
        panel.select("#detail-type").text(d.type);
        panel.select("#detail-condition").text(d.condition);
        panel.select("#detail-cluster").text(d.cluster);
        
        updateExpressionChart(d);

        panel.classed("active", true);
    }

    function updateExpressionChart(d) {
        const chartDiv = d3.select("#expression-chart");
        chartDiv.html(""); 

        if (!geneExpression) return;

        // Find index of d in rawData
        // Since rawData is loaded from cells.json and d is an element of it, we can find index.
        // However, d might be a reference from the joined data. 
        // Ideally d is the object from rawData.
        const index = rawData.indexOf(d);
        
        if (index === -1) return;

        const genes = Object.keys(geneExpression);
        if (genes.length === 0) {
            chartDiv.html("<p>No gene data available</p>");
            return;
        }

        chartDiv.append("div")
            .style("font-weight", "bold")
            .style("font-size", "12px")
            .style("margin-bottom", "8px")
            .style("border-bottom", "1px solid #444")
            .style("padding-bottom", "4px")
            .text("Marker Genes");

        genes.forEach(gene => {
            const val = geneExpression[gene][index];
            const maxVal = 3.0; // Assumption for visualization scaling
            const pct = Math.min(100, (val / maxVal) * 100);
            
            const row = chartDiv.append("div")
                .style("margin-bottom", "6px");
                
            const labelRow = row.append("div")
                .style("display", "flex")
                .style("justify-content", "space-between")
                .style("font-size", "11px")
                .style("margin-bottom", "2px");
            
            labelRow.append("span").text(gene);
            labelRow.append("span").text(val.toFixed(2));

            const barBg = row.append("div")
                .style("width", "100%")
                .style("height", "6px")
                .style("background", "#333")
                .style("border-radius", "3px")
                .style("overflow", "hidden");
                
            barBg.append("div")
                .style("width", `${pct}%`)
                .style("height", "100%")
                .style("background", "#4e79a7");
        });
    }

    function clearSelection() {
        selectedNodeId = null;
        d3.select("#details-panel").classed("active", false);
        // Also close literature panel to clean up
        closeLiterature();
        
        nodeGroup.selectAll(".node")
            .classed("faded", false)
            .classed("active-node", false)
            .style("opacity", 1)
            .select("circle").attr("stroke", "#000").attr("stroke-width", 0.5);
    }

</script>
</body>
</html>

